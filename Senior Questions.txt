
1) В каком домене Domain были задачи ? Medical домент.
2) С каким технологиями работал .NET Framework или .NET Core ? 
3) Какие методы рефакторинга ты бы предложил ? (нужно больше внедрения зависимостей)
4) Как антипаттерны можно превратить в что то хорошее ?
5) SOLID что такое, как юзать как использовать ?
6) Как описать типовой пример нарушения принципа Single Responsibility ?
7) Не смешивать бизнес логику и инфраструктуру.
8) Нарушение кода OCP Open Close принципа пример нарущения. (не менять код или использовать sub классы или интерфейсы)
   (Нарушение видно когда в наследниках не согласованное поведение)
9) 4 принцип солид -  не лепить много методов в интерфейсы а дробить интерфейси что бы наследники иплементили которые он хочет интерфейсы (что бы не имплементить лишнее)

10) Принципы без которых ты не напишишь юнит тесты ? 
- Без принципа Dependency Inversion (если зависемости будут создаваться, а не инжектится, то юнит тесты будет написать очень сложно)
11) Если есть зависимость на статику, как написать юнит тест на такой метод ? Враппер написать свой собственный на статику и замокать (в реализации этого интерфейса будет вызовать статик метод)
12) GoF паттерны, какие приминял. Порождающие Структурные Поведенчиские, по одному из каждой группы
13) Паттерн Мост (Bridge)
14) GRASP дизайн - Low Coupling, High Cohesion, Polymorphism, Pure Fabrication
15) Базы даннык, какие использовал ? разница SQL и NoSQL когда и что использовать
16) Serverless подход, какие проблемы (холодный и горячий старт) (самый холодный на джаве), код должен выполнятся максимально быстро в функциях. (в Сервис плане можно уменьший время холодного старта)
17) SQL базы, принцип ACID, рассказать об этом. Атомарность в транзакциях. Consistency данные должны быть согласованны Isolation - транзакция должны быть изолированны 
ACID - требования к транзакционной системе

4-5 уровней транзакций в SQL базе есть 
4 - минимум уровня изоляции в SQL базе
5 - не во всех базах есть столько
Фантомы - это такие штуки что в рамках транзхакции может что то создаватся или удалятся и другая транзакция может их получить
Serialazble уровнь помогает избавется это фантомов в базе
18) CAP теорема для расспределенных систем. (часто в микросервесной системе юзается)
19) Триггеры в SQL
20) REST принципы, Идемпотентность в REST API - части HTTP (Verbs) методов Идемпотентность а часть не идемпотентность
21) 
  Доменные микросервисы DDD - Domain Driven Development - каждый микросервис строится вокгур какой то доменной сузности User, Account, Employee
  Инфраструктурные микросервисы - Logger, Audit, Getway или что то что могу все использовать 
22) CDN

23) алгоритмы хеширования - Sha1 SHA256, шифрования - симетричное и асиметричное


Combined Index in SQL 
у меня есть комбенированый индекс в SQL в чем проблема поиска по второму полю ?

ChatGPT
Когда вы создаёте комбинированный (или составной) индекс в SQL, индекс работает эффективно только при соблюдении порядка полей, указанных при его создании. Проблема поиска по второму полю в составе комбинированного индекса связана с принципами работы индексов и тем, как SQL использует их для оптимизации запросов.

Принципы работы комбинированного индекса
Рассмотрим индекс, созданный следующим образом:

sql
Copy code
CREATE INDEX idx_example ON table_name (column1, column2);
Этот индекс эффективно используется в следующих сценариях:

Поиск по column1.
Поиск по комбинации column1 и column2.
Поиск по column1 с сортировкой по column2.
Однако, если вы выполняете запрос только по column2, SQL не сможет использовать этот индекс напрямую, поскольку индексы упорядочены сначала по column1, а затем по column2. Поиск по column2 без указания значения column1 требует полного обхода индекса (или полного сканирования таблицы), что делает использование индекса неэффективным или вовсе невозможным.

Примеры запросов и их использование индекса
Поиск по column1:

sql
Copy code
SELECT * FROM table_name WHERE column1 = 'value1';
Этот запрос эффективно использует индекс idx_example.

Поиск по column1 и column2:

sql
Copy code
SELECT * FROM table_name WHERE column1 = 'value1' AND column2 = 'value2';
Этот запрос также эффективно использует индекс idx_example.

Поиск по column2 (проблемный сценарий):

sql
Copy code
SELECT * FROM table_name WHERE column2 = 'value2';
Этот запрос не может эффективно использовать индекс idx_example, так как в индексе нет упорядоченности по column2 без учета column1.

Решения проблемы
Чтобы эффективно выполнять запросы по column2, вы можете рассмотреть следующие варианты:

Создание отдельного индекса для column2:

sql
Copy code
CREATE INDEX idx_column2 ON table_name (column2);
Этот индекс будет использоваться для запросов, которые ищут только по column2.

Создание комбинированного индекса с column2 в первой позиции (если это имеет смысл для большинства запросов):

sql
Copy code
CREATE INDEX idx_example2 ON table_name (column2, column1);
Этот индекс можно использовать для запросов по column2, а также для запросов по комбинации column2 и column1.

Использование других методов оптимизации запросов, таких как денормализация данных или изменение структуры запросов и данных, чтобы максимально использовать имеющиеся индексы.

Заключение
Проблема поиска по второму полю комбинированного индекса заключается в том, что индексы эффективно работают при соблюдении порядка полей, указанных при создании индекса. Чтобы устранить эту проблему, необходимо либо создать отдельный индекс для второго поля, либо изменить структуру существующих индексов, чтобы они соответствовали типам запросов, выполняемым в вашей базе данных.
